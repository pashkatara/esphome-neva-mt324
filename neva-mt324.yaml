esphome:
  name: neva-meter
  comment: "Счетчик Нева МТ 324 (RS485)"

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: DEBUG
  baud_rate: 0 # Отключаем логгер на UART0, чтобы не мешать

# Настройка WiFi (замените на свои данные)
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Neva Meter Fallback"
    password: "12345678"

captive_portal:

# Web Server для отладки (можно убрать в продакшене)
web_server:
  port: 80

# НАСТРОЙКА UART
# Обратите внимание на нестандартные параметры: 7 бит, четность Even
uart:
  id: uart_bus
  tx_pin: GPIO5
  rx_pin: GPIO4
  baud_rate: 9600
  data_bits: 7
  parity: EVEN
  stop_bits: 1

# СЕНСОРЫ
sensor:
  # --- НАПРЯЖЕНИЯ ---
  - platform: template
    name: "Напряжение L1"
    id: v_l1
    unit_of_measurement: "V"
    accuracy_decimals: 1
    device_class: voltage
  - platform: template
    name: "Напряжение L2"
    id: v_l2
    unit_of_measurement: "V"
    accuracy_decimals: 1
    device_class: voltage
  - platform: template
    name: "Напряжение L3"
    id: v_l3
    unit_of_measurement: "V"
    accuracy_decimals: 1
    device_class: voltage
    
  # --- ТОКИ ---
  - platform: template
    name: "Ток L1"
    id: i_l1
    unit_of_measurement: "A"
    accuracy_decimals: 2
    device_class: current
  - platform: template
    name: "Ток L2"
    id: i_l2
    unit_of_measurement: "A"
    accuracy_decimals: 2
    device_class: current
  - platform: template
    name: "Ток L3"
    id: i_l3
    unit_of_measurement: "A"
    accuracy_decimals: 2
    device_class: current

  # --- МОЩНОСТЬ ---
  - platform: template
    name: "Суммарная мощность"
    id: p_total
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    
  # --- ЭНЕРГИЯ (ТАРИФЫ) ---
  - platform: template
    name: "Энергия Т1"
    id: energy_t1
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    device_class: energy
    state_class: total_increasing
  - platform: template
    name: "Энергия Т2"
    id: energy_t2
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    device_class: energy
    state_class: total_increasing
  - platform: template
    name: "Энергия Всего"
    id: energy_total
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    device_class: energy
    state_class: total_increasing

# ЛОГИКА ОПРОСА
interval:
  - interval: 10s
    then:
      - lambda: |-
          // --- Вспомогательные функции ---
          auto flush_wait = [&]() { 
            delay(50); 
            while(id(uart_bus).available()) { 
              uint8_t b; 
              id(uart_bus).read_byte(&b); 
              delay(1);
            } 
          };
          
          auto read_packet = [&](int timeout_ms) -> std::vector<uint8_t> {
            std::vector<uint8_t> data;
            uint32_t start = millis();
            while (millis() - start < timeout_ms) {
              if (id(uart_bus).available()) {
                uint8_t b;
                id(uart_bus).read_byte(&b);
                data.push_back(b);
                // 0x03 - символ окончания пакета
                if (b == 0x03) {
                  delay(20); 
                  // Считываем CRC (последний байт)
                  if (id(uart_bus).available()) id(uart_bus).read_byte(&b);
                  break;
                }
              }
            }
            return data;
          };
          
          auto calc_crc = [&](const uint8_t *data, size_t len) -> uint8_t {
            uint8_t crc = 0;
            for (size_t i = 0; i < len; i++) crc ^= data[i];
            return crc;
          };

          // Функция отправки запроса по OBIS-коду
          auto send_request = [&](std::string obis_code) -> float {
             std::vector<uint8_t> req_payload;
             req_payload.push_back('R');
             req_payload.push_back('1');
             req_payload.push_back(0x02); 
             for(char c : obis_code) req_payload.push_back(c);
             req_payload.push_back('(');
             req_payload.push_back(')');
             req_payload.push_back(0x03); 
             
             uint8_t req_crc = calc_crc(req_payload.data(), req_payload.size());
             
             std::vector<uint8_t> full_req;
             full_req.push_back(0x01); // Start byte
             full_req.insert(full_req.end(), req_payload.begin(), req_payload.end());
             full_req.push_back(req_crc);
             
             id(uart_bus).write_array(full_req.data(), full_req.size());
             delay(150); 
             
             auto resp = read_packet(500);
             std::string s(resp.begin(), resp.end());
             
             size_t start_p = s.find('(');
             size_t end_p = s.find(')');
             
             if (start_p != std::string::npos && end_p != std::string::npos && end_p > start_p) {
                std::string val = s.substr(start_p + 1, end_p - start_p - 1);
                ESP_LOGD("Neva", "Read %s -> %s", obis_code.c_str(), val.c_str());
                return atof(val.c_str());
             }
             ESP_LOGW("Neva", "Failed to read %s", obis_code.c_str());
             return 0.0;
          };

          // --- ОСНОВНОЙ ЦИКЛ СЕАНСА ---
          ESP_LOGI("Neva", "--- START SESSION ---");
          
          // 1. Инициализация
          flush_wait();
          id(uart_bus).write_str("/?!\r\n");
          
          // Ждем идентификацию
          uint32_t start = millis();
          while (millis() - start < 500) {
             if (id(uart_bus).available()) {
               uint8_t b;
               id(uart_bus).read_byte(&b);
               if (b == '\n') break;
             }
          }
          
          // 2. Переключение скорости (Option Select)
          flush_wait();
          uint8_t switch_cmd[] = {0x06, '0', '5', '1', 0x0D, 0x0A}; 
          id(uart_bus).write_array(switch_cmd, 6);
          delay(500); 
          flush_wait(); 

          // 3. Авторизация (Password P1)
          uint8_t auth_payload[] = {'P', '1', 0x02, '(', '0', '0', '0', '0', '0', '0', '0', '0', ')', 0x03};
          uint8_t auth_crc = calc_crc(auth_payload, 14);
          
          std::vector<uint8_t> auth_packet;
          auth_packet.push_back(0x01); 
          auth_packet.insert(auth_packet.end(), auth_payload, auth_payload + 14);
          auth_packet.push_back(auth_crc);
          
          id(uart_bus).write_array(auth_packet.data(), auth_packet.size());
          delay(200); 
          uint8_t ack = 0;
          if(id(uart_bus).available()) id(uart_bus).read_byte(&ack);
          
          if (ack == 0x06) {
             ESP_LOGI("Neva", "Auth Success!");
             flush_wait();

             // --- ЧТЕНИЕ МГНОВЕННЫХ ЗНАЧЕНИЙ ---
             
             // Напряжения (V)
             // L1: OBIS 20.7.0 (Hex 20)
             id(v_l1).publish_state(send_request("200700FF"));
             // L2: OBIS 52.7.0 (Hex 34)
             id(v_l2).publish_state(send_request("340700FF"));
             // L3: OBIS 72.7.0 (Hex 48)
             id(v_l3).publish_state(send_request("480700FF"));

             // Токи (A)
             // L1: OBIS 31.7.0 (Hex 1F)
             id(i_l1).publish_state(send_request("1F0700FF"));
             // L2: OBIS 51.7.0 (Hex 33)
             id(i_l2).publish_state(send_request("330700FF"));
             // L3: OBIS 71.7.0 (Hex 47)
             id(i_l3).publish_state(send_request("470700FF"));

             // Мощность (W)
             // Total: OBIS 16.7.0 (Hex 10)
             id(p_total).publish_state(send_request("100700FF"));

             // --- ЧТЕНИЕ ТАРИФОВ ---
             // Запрос на массив значений (OBIS 15.8.0)
             std::vector<uint8_t> tariff_req;
             tariff_req.push_back('R');
             tariff_req.push_back('1');
             tariff_req.push_back(0x02);
             std::string t_obis = "0F0880FF";
             for(char c : t_obis) tariff_req.push_back(c);
             tariff_req.push_back('(');
             tariff_req.push_back(')');
             tariff_req.push_back(0x03);
             
             uint8_t t_crc = calc_crc(tariff_req.data(), tariff_req.size());
             
             std::vector<uint8_t> full_t_req;
             full_t_req.push_back(0x01);
             full_t_req.insert(full_t_req.end(), tariff_req.begin(), tariff_req.end());
             full_t_req.push_back(t_crc);
             
             id(uart_bus).write_array(full_t_req.data(), full_t_req.size());
             delay(200);
             
             auto t_resp = read_packet(500);
             std::string t_str(t_resp.begin(), t_resp.end());
             
             size_t t_start = t_str.find('(');
             size_t t_end = t_str.find(')');
             
             if (t_start != std::string::npos && t_end != std::string::npos && t_end > t_start) {
                 // Парсинг строки: "Total,T1,T2,..."
                 std::string vals = t_str.substr(t_start + 1, t_end - t_start - 1);
                 std::vector<std::string> tokens;
                 size_t pos = 0;
                 std::string delimiter = ",";
                 std::string token;
                 while ((pos = vals.find(delimiter)) != std::string::npos) {
                     token = vals.substr(0, pos);
                     tokens.push_back(token);
                     vals.erase(0, pos + delimiter.length());
                 }
                 tokens.push_back(vals);
                 
                 if (tokens.size() >= 3) {
                     id(energy_total).publish_state(atof(tokens[0].c_str()));
                     id(energy_t1).publish_state(atof(tokens[1].c_str()));
                     id(energy_t2).publish_state(atof(tokens[2].c_str()));
                 }
             }
             flush_wait();

          } else {
             ESP_LOGE("Neva", "Auth Failed! Check wiring or password.");
          }
